# IPC

## 1.pipe - 匿名管道
原理：管道实为内核使用环形队列机制，借助内核缓冲区实现。
```cpp
int fd[2]; // 0:读端 1：写端
pipe(fd);
```
优点：简单
缺点：
* ① 只能在有血缘关系的进程间使用
* ② 管道中数据不可反复读取。一旦读走，管道中不再存在
* ③ 采用半双工通信方式，数据只能在单方向上流动

## 2.fifo - 命名管道
FIFO 是 Linux 基础文件类型中的一种 。
但FIFO 文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。
各进程可以打开这个文件进行 read /write 实际上是在读写内核通道 ，这样就实现了进程间通信。
```cpp
mkfifo filename// 命令行创建
int mkfifo(const char *path, mode_t mode); // 函数创建
```
优点：
* ① 简单
* ② 可在无血缘关系的进程间使用

缺点：
* ① 管道中数据不可反复读取。一旦读走，管道中不再存在
* ② 采用半双工通信方式，数据只能在单方向上流动

## 3.mmap - 共享存储映射
存储映射I/O（Memory mapped I/O） 使一个磁盘文件与存储空间中的一个缓冲区相映射。
于是当从缓冲区中取数据就相当于读文件中的相应字节；将数据存入缓冲区则类似将相应的字节写入文件。
这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I/O操作。

![avatar](./imgs/mmap.jpg)

```cpp
void* mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);
// 返回值为void*，因为内核不知道该段内存将要存放的数据类型
```
优点：
* ① 通过指针，操作多种多样
* ② 可在无血缘关系的进程间使用

缺点：
* ① 出错概率高
* ② 小文件mmap可能造成内存浪费

特点：
* 1. 创建映射区的过程中，隐含着一次对映射文件的读操作。
* 2. 当```MAP_SHARED```时，要求：映射区的权限应小于等于文件打开的权限出于对映射区的保护。而```MAP_PRIVATE```则无所谓， 因为```mmap```中的权限是对内存的限制。
* 3. 映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。
* 4. 特别注意，当映射文件大小为 0 时，不能创建映射区。**所以：用于映射的文件必须要有实际大小！！**
* 5. **```munmap```传入的地址一定是```mmap```的返回地址。坚决杜绝指针++操作。**
* 6. 文件偏移量必须为```4K```的整数倍
* 7. ```mmap```创建映射区出错概率非常高 一定要检查返回值，确保映射区建立成功再进行后续操作。

---

# 线程间同步

## 1.同步
“同步”的目的，是**避免数据混乱，解决与时间有关的错误**。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。
因此， **所有“多个控制流共同操作一个共享资源” 的情况**，都需要同步。

## 2.线程同步

线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。

### 2.1 互斥量Mutex
```cpp
#include <mutex>
std::mutex mutex; // 该锁应全局共享
int global_var = 100; // 共享资源

void threadFunc()
{
    // .......
    {
        // 加锁。若不成功则阻塞等待
        std::lock_guard<std::mutex> lock(mutex_); 
        // 获得锁，访问共享资源;其他线程无法取得锁
        global_var = 200;
    }
    // lock_guard析构，解锁;其他线程可以取得锁
    // .......
}
```
* 1. 每个线程在**对资源操作前都尝试先加锁**，成功加锁才能操作，**操作结束解锁**
* 2. 同一时刻，只能有一个线程持有该锁
* 3. 互斥锁实质上是操作系统提供的一把“建议锁”，**并没有强制限定**
* 4. **锁的粒度要尽量小**，在访问完成后立即解锁，减少等待时间

#### 死锁
四个条件：
1. 互斥原则
2. 请求并保持
3. 已有不剥夺
4. 循环等待


## 2.2 读写锁
考虑某种**读多写少**的场景，如余额查询；某个线程在读共享数据的时候其他线程不能读，这显然是不合理的；原因是**没有区分访问的类型**。
更好的解决方案是：**写独占，读共享**。
```cpp
// 创建一把读写锁
pthread_rwlock_t rwlock;

// 初始化读写锁
// attr表读写锁属性，通常使用默认属性,传NULL即可
int pthread_rwlock_init(pthread_rwlock_t *lock, const pthread_rwlockattr_t *attr);

// 写加锁
pthread_rwlock_wrlock(&rwlock)；

// 读加锁
pthread_rwlock_rdlock(&rwlock);

// 解锁
pthread_rwlock_unlock(&rwlock);

```
#### 读写锁特性：
* 1. “写模式加锁”时，**解锁前，所有对该锁加锁的线程都会被阻塞**。
* 2. “读模式加锁”时，**如果线程以读模式对其加锁会成功；以写模式加锁会阻塞。**
* 3. 读锁、写锁并行阻塞，**写锁优先级高**

## 2.3 条件变量
**条件变量不是锁**，只是提供一个场所，让所有线程在此交汇；但是其本质也是对共享资源的访问，所以要搭配一把锁使用。

### 生产者-消费者模型
既然线程是在等待条件满足，那么很容易想到**生产者-消费者模型**——生产线程产出一个产品后，则通知消费线程条件满足（**队列不为空**），消费线程则被唤醒，进行消费。

```cpp
// 显然，条件变量和锁都应该是全局共享
std::mutex mutex;
std::condition_variable cv;
std::queue<T> queue; // 共享资源

void consumer()
{
    // ......
    std::unique_lock<std::mutex> lock(mutex);
    while(/* 条件不满足 */)
    {
        // 解锁，阻塞等待条件满足
        cv.wait(lock);
        // 当条件满足，该阻塞线程被唤醒
        // 再次检查是否满足条件
    }
    // 条件满足，获得锁，进行访问
    // ......
}

void producer()
{
    // ......
    // 生产并放入队列
    queue.emplace_back(T);
    // 唤醒一个阻塞的消费线程
    cv.notify();
    // ......
}
```
#### 优点：
**相较于mutex而言，条件变量可以减少竞争。**
如直接使用mutex，**如果临界区中没有数据，消费者之间竞争mutex是无意义的**。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。

#### 注意点：
* 1.多个消费者线程存在时，线程被唤醒，可能其它线程已经消费，条件此时并不满足，即**虚假唤醒**；应该使用```while()```来进行条件判断。
* 2.在代码块结束后将释放锁；**妥善考虑代码块结束的位置**。
* 3.可以通过生产特殊的商品来控制消费者线程退出。
* 4.当封装成```BoundedBlockingQueue```对象，在**析构时一定要唤醒所有线程并通过标志位指导其退出**，才能避免一直阻塞不能对其进行回收。

## 2.4 信号量
信号量的概念错综复杂，这里只讲自己的想法：

* 1.```Semaphore```可以初始化为任何非负整数
* 2.```Semaphore```值大于0时，线程**获取资源**，并且```--Semaphore```；等于0时，代表已经没有资源，线程挂起等待
* 3.当线程使用完资源之后，```++Semaphore```。

* 4.**资源可以是访问临界区的权限（取完后不能再进入），也可以是共享资源的个数（取完后不能再取出）**

根据上面的分析，信号量有下列用途：
* 1.初始化为1：此时相当于互斥锁
* 2.初始化为非负整数N：代表有N个线程可以访问临界区/有N个共享资源可以取用

更多的细节参考：
https://zhuanlan.zhihu.com/p/112173283

---


