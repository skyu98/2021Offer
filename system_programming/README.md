# IPC

## 1.pipe - 匿名管道
原理：管道实为内核使用环形队列机制，借助内核缓冲区实现。
```cpp
int fd[2]; // 0:读端 1：写端
pipe(fd);
```
优点：简单
缺点：
* ① 只能在有血缘关系的进程间使用
* ② 管道中数据不可反复读取。一旦读走，管道中不再存在
* ③ 采用半双工通信方式，数据只能在单方向上流动

## 2.fifo - 命名管道
FIFO 是 Linux 基础文件类型中的一种 。
但FIFO 文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。
各进程可以打开这个文件进行 read /write 实际上是在读写内核通道 ，这样就实现了进程间通信。
```cpp
mkfifo filename// 命令行创建
int mkfifo(const char *path, mode_t mode); // 函数创建
```
优点：
* ① 简单
* ② 可在无血缘关系的进程间使用

缺点：
* ① 管道中数据不可反复读取。一旦读走，管道中不再存在
* ② 采用半双工通信方式，数据只能在单方向上流动

## 3.mmap - 共享存储映射
存储映射I/O（Memory mapped I/O） 使一个磁盘文件与存储空间中的一个缓冲区相映射。
于是当从缓冲区中取数据就相当于读文件中的相应字节；将数据存入缓冲区则类似将相应的字节写入文件。
这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I/O操作。

![avatar](./imgs/mmap.jpg)

```cpp
void* mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);
// 返回值为void*，因为内核不知道该段内存将要存放的数据类型
```
优点：
* ① 通过指针，操作多种多样
* ② 可在无血缘关系的进程间使用

缺点：
* ① 出错概率高
* ② 小文件mmap可能造成内存浪费

特点：
* 1. 创建映射区的过程中，隐含着一次对映射文件的读操作。
* 2. 当```MAP_SHARED```时，要求：映射区的权限应小于等于文件打开的权限出于对映射区的保护。而```MAP_PRIVATE```则无所谓， 因为```mmap```中的权限是对内存的限制。
* 3. 映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。
* 4. 特别注意，当映射文件大小为 0 时，不能创建映射区。**所以：用于映射的文件必须要有实际大小！！**
* 5. **```munmap```传入的地址一定是```mmap```的返回地址。坚决杜绝指针++操作。**
* 6. 文件偏移量必须为```4K```的整数倍
* 7. ```mmap```创建映射区出错概率非常高 一定要检查返回值，确保映射区建立成功再进行后续操作。

---

# 线程间同步

## 1.同步
“同步”的目的，是**避免数据混乱，解决与时间有关的错误**。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。
因此， **所有“多个控制流共同操作一个共享资源” 的情况**，都需要同步。

## 2.线程同步

线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。

### 2.1 互斥量Mutex
```cpp
#include <mutex>
std::mutex mutex; // 该锁应全局共享
int global_var = 100; // 共享资源

void threadFunc()
{
    // .......
    {
        // 加锁。若不成功则阻塞等待
        std::lock_guard<std::mutex> lock(mutex_); 
        // 获得锁，访问共享资源;其他线程无法取得锁
        global_var = 200;
    }
    // lock_guard析构，解锁;其他线程可以取得锁
    // .......
}
```
* 1. 每个线程在**对资源操作前都尝试先加锁**，成功加锁才能操作，**操作结束解锁**
* 2. 同一时刻，只能有一个线程持有该锁
* 3. 互斥锁实质上是操作系统提供的一把“建议锁”，**并没有强制限定**

### 2.2 死锁
四个条件：
1. 互斥原则：
2. 请求并保持
3. 已有不剥夺
4. 循环等待





## 生产者-消费者模型