[toc]
# 计算机网络
## 四层网络模型

---

## TCP

### 一、TCP细节
* 1. **第三次握手ACK**可以携带数据；**FIN报文段**可以携带数据
* 2. 在**连接建立后所有传送的报文ACK位必须置1**
* 3. SYN和FIN都会消耗一个序列号


### 二、TCP的各种异常情况
#### 1.三次握手异常（假设客户端为主动打开端）
* 1.第一次握手失败(客户端发送SYN，没有到达服务器)：
    * 客户端按**逐渐增大的时间间隔**进行重发，累计75s后返回```ETIMEOUT```
    * 服务端无感知
<br>
* 2.第二次握手失败（服务端发送SYN+ACK，没有到达客户端）：
    * 对于客户端而言等效于第一次失败(重发)
    * 服务器超时重传后，**发送RST，关闭连接**；客户端收到后返回```ECONNREFUSED```
<br>
* 3.第三次握手失败（客户端回复ACK，没有到达服务端）：
    * 对于服务端等效于第二次失败（未收到ACK）
    * **客户端认为连接已建立，发送数据；服务端以RST回应**
<br>
* 4.目的不可达ICMP错误
    * 客户端返回```ENETUNREACH```
<br>
* 5.客户端在**服务端accept之前断开连接**
    * 建立三次握手之后，调用accept之前，可能出现客户端断开连接的情况
    * **完成三次握手的连接会从已完成队列中移除**
    * ```accept```调用中忽略以下错误:
    ```EWOULDBLOCK, ECONNABORTED,EPROTO,EINTR```；

#### 2. **CLOSE_WAIT状态过多**怎么处理？
* 出现原因：被动关闭端接收FIN并回复ACK后，进入CLOSE_WAIT状态；发送完数据之后，被动端调用```close()```发送FIN，进入LAST_ACK状态————**CLOSE_WAIT状态过多说明被动端忙于读写或阻塞，没有调用```close()```**
<br>
* 解决办法：
    * 1. 使用完socket调用close方法；
    * 2. socket读控制，当read返回0时（读到结尾），立即close；如果read返回-1，检查error返回码；如果不是```EAGAIN```，立即close；
    * 3. 数据库连接和访问等要**设置超时时间，避免阻塞；**
    * 4. 可以设置TCP的连接时长keep_alive_time

#### 3.更多异常情况
https://www.cnblogs.com/wanpengcoder/p/5356776.html

### 三、TCP的缺点？怎么优化？
---
## HTTP
### 一、简介
* 1. HTTP是TCP/IP中的一个应用层协议；用来协议数据交换过程和数据本身的格式。
* 2. HTTP服务器**不维护客户的状态信息**，即HTTP是一个无状态的协议(`stateless protocol`)。
* 3. HTTP的格式为请求头`Header` + 主体`body`，后者又是K-V的形式

### 二、Http缺点
* 1. 无状态--双刃剑 ： 在进行有关联性操作时每一步需要重复验证状态。（**Cookies解决**）
* 2. 明文传输：GET/POST 所有的信息都没有进行加密，容易泄漏
* 3. **不安全** ：
    * 明文传输（窃听风险）
    * 连接时还不会验证双方身份（冒充风险）
    * 报文内容可能被篡改（篡改风险）

### 二、HTTP演变
#### HTTP/1.0
最基本的版本。
* HTTP/1.0规定浏览器与服务器**只保持短暂的连接**，十分影响性能。

#### HTTP/1.1特点
* 1. **默认持久连接**
    * 字段`Connection: keep-alive`

* 2. **管道传输机制**
    * 在同一个tcp的连接中可以传送多个HTTP请求和响应，但必须按照顺序.**一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接**
    * **队头阻塞**问题

* 3. 更加多的请求头和响应头(比如HTTP1.0没有的**Host的字段，用于访问多个虚拟站点中的一个**).

* 4. 支持多次请求，但是相似或相同的请求**并没有压缩头部**

#### HTTP/2.0（基于HTTPS）
* 1. **头部压缩**：维护一张**编号<-->头部信息**的索引表
* 2. **二进制表示**：Header和Body都用二进制表示，变为**头部信息帧和数据帧**
* 3. **数据流**：不再按顺序发送，而是**属于每个请求的数据包用独特的编号来标识**。 
* 4. **多路复用**：由于有了编号，请求可以不再串行。解决了队头阻塞问题。
* 5. **服务器推送**：刚刚建立请求时，服务器可以主动发送静态资源。
* 6. **丢包阻塞**：多个请求复用一个TCP连接，当发生丢包时，所有的HTTP请求都会阻塞

#### HTTP/3.0
* 1. **UDP协议**：使用UDP协议来避免队头阻塞和丢包阻塞
* 2. **QUIC协议**：使不面向可靠连接的UDP也能可靠地传输数据；同时减少握手次数到3次
* 3. **TLS1.3**
<br>
![avator](./imgs/http.jpg)

https://blog.csdn.net/u012813201/article/details/70211255

### 三、HTTPS
为了解决上面提到的安全问题，HTTPS协议在应用层HTTP和传输层TCP协议之间，
添加了一层**SSL/TLS**协议，很好地解决了上述问题。

**公钥加密，私钥解密；私钥签名，公钥验签。**

1. **混合加密**（解决窃听风险）：
    * 非对称加密（四次握手）：**不易被破解，但效率较低**
        * 首先是客户端发起连接，三次TCP握手
        * 客户端发送**随机数N1**和密码套件
        * 服务端收到请求，回复**随机数N2**、密码套件和**CA证书**（内容经过CA私钥签名，包含**服务器的信息和公钥**）
        * 客户端收到证书，用CA公钥进行检验，通过之后**发送服务端公钥加密之后**的**随机数N3**、加密转化通知、握手摘要等
        * 服务端进行回复：加密转化通知、握手摘要
    
    * 对称加密：**效率高但易被破解**
       **N1 + N2 + N3 + 协商的加密算法 => 会话密钥**
        此后的会话都使用该密钥加密和解密。
<br>       

2. **摘要算法**：私钥生成内容摘要 -> 公钥验证完整性 （解决篡改风险）
3. **数字证书**：服务器向CA注册证书 -> 客户端可通过CA公钥验证身份（解决冒充风险）

---

## IP
### 一.简介
* 位于**网络层**的协议--用于**主机和主机之间**的通信

* IP协议**不保证传输的可靠性**，数据包在传输过程中可能丢失，**可靠性可以在上层协议或应用程序中提供支持**

* `ICMP`
    * 用于告知传输过程中的**错误及控制信息**
    * 同样**需要加上IP包头**

* `ARP`
    * 在子网内广播，IP对应的网卡会**填上自己的MAC地址**并回复
    * 如果目标主机不在本子网中，则**通过路由器传递到下一个子网**
    * 找到后会**保存在本地缓存**中

### 二、头部
* **源IP地址、目标IP地址**：用于**远程标识**网络中的主机

* **TTL（Time To Live）**：源主机为数据包**设定一个生存时间**（单位为hop），每过一个路由器就把该值减1，如果减到0就仍然找不到目的主机的网络，就丢弃该包

* **16位标识、3位标志+13位片偏移**：受MTU（最大传输单元，**以太网帧中为1500字节有效载荷**）限制，如果IP中的数据过大，则需要进行分片；而**目标主机收到所有分片后，依据上述头部标志位进行重组**。
    * **如果一个分片丢失，整个IP数据报都被丢弃**
    * 尽量在传输层就进行分片：**TCP中有MSS（最大报文长度）；UDP我们尽量每次不发送超过MTU的字节。**

---
# 一次网络传输发生了什么
https://www.cnblogs.com/Jack-Blog/p/13426728.html
## 在浏览器输入`URL`回车之后发生了什么？
#### 应用层 —— HTTP协议
* 1. 首先需要解析「**网址**」，**生成`Http`请求消息包**

* 2. 查询`Web`服务器域名对应的「**IP地址**」
    * 在`DNS`服务器中进行查询（使用`UDP`，递归/迭代查询）
    * 获取**IP地址**后交给**TCP/IP协议栈**处理

#### 传输层 —— TCP协议
* 3. `TCP`头部填入**本端端口号**，**对端端口号**
* 4. 由于需要建立连接，需要**将标志位置为`SYN`**；还包含有**本端`MSS`、窗口大小**等信息
* 5. 如果数据长度超过`MSS`，还需要进行分片

#### 网络层 —— IP协议
* 6. `IP`头部填入**本端IP地址**，**对端IP地址**
* 7. 如果数据报长度超过`MTU`,还需要进行分片

#### 网络链路层 —— ARP协议
* 在**两点之间直接传递**需要`MAC`地址
* 8. **ARP协议广播**得到目标`MAC`地址，填入到数据帧头部

#### 后续 —— 硬件
* 9. 通过**交换机、路由器**等中间过程，到达目标主机
* 10. 目标主机**逐层拆包**，将数据交给对应的进程处理（后入的协议先处理，**栈**的含义）

## 网络传输中具体系统做了什么
这里我们关注某台主机的网卡**发送和接收消息**时，会发生什么。

### 发送数据
* 1. 建立`TCP`连接时，会先创建`Socket`；其中包含**发送缓冲区和接收缓冲区**等
* 2. 当应用层**调用发送接口**时，**只是把数据存入发送缓冲区，具体什么时候发送由TCP协议决定**
* 3. IP模块执行完成之后（**以太网帧已经生成**）就会**调用网卡驱动**执行发送数据
* 4. 网卡驱动**将数据包复制到网卡的缓冲区**中，然后会在包的**开头添加报头和起始帧分界符**，在**包尾添加用于检测错误的帧校验序列(FCS)**

### 接受数据
* 1. 网卡接收到数据，进行**地址和内容校验**，若通过则拷贝到**网卡缓冲区**
* 2. 网卡发起**中断**（外中断），`CPU`调用**中断处理程序，其中再调用网卡驱动**
* 3. 通过**直接IO**或**DMA**方式，将网卡缓冲区的数据拷贝到内存中，**交给协议栈进行拆包**
* 4. 拆包过程中**发生的错误，大多会通过ICMP协议通知源主机**
---
# Linux 网络编程
## 常见Linux网络相关指令
netstat
tcpdump
nc