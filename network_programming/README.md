[toc]
# 计算机网络
## 在浏览器输入 URL 回车之后发生了什么？
https://blog.csdn.net/qq_38408785/article/details/100886278

---

## TCP

### 一、TCP细节
* 1. **第三次握手ACK**可以携带数据；**FIN报文段**可以携带数据
* 2. 在**连接建立后所有传送的报文ACK位必须置1**
* 3. SYN和FIN都会消耗一个序列号


### 二、TCP的各种异常情况
#### 1.三次握手异常（假设客户端为主动打开端）
* 1.第一次握手失败(客户端发送SYN，没有到达服务器)：
    * 客户端按**逐渐增大的时间间隔**进行重发，累计75s后返回```ETIMEOUT```
    * 服务端无感知
<br>
* 2.第二次握手失败（服务端发送SYN+ACK，没有到达客户端）：
    * 对于客户端而言等效于第一次失败(重发)
    * 服务器超时重传后，**发送RST，关闭连接**；客户端收到后返回```ECONNREFUSED```
<br>
* 3.第三次握手失败（客户端回复ACK，没有到达服务端）：
    * 对于服务端等效于第二次失败（未收到ACK）
    * **客户端认为连接已建立，发送数据；服务端以RST回应**
<br>
* 4.目的不可达ICMP错误
    * 客户端返回```ENETUNREACH```
<br>
* 5.客户端在**服务端accept之前断开连接**
    * 建立三次握手之后，调用accept之前，可能出现客户端断开连接的情况
    * **完成三次握手的连接会从已完成队列中移除**
    * ```accept```调用中忽略以下错误:
    ```EWOULDBLOCK, ECONNABORTED,EPROTO,EINTR```；

#### 2. **CLOSE_WAIT状态过多**怎么处理？
* 出现原因：被动关闭端接收FIN并回复ACK后，进入CLOSE_WAIT状态；发送完数据之后，被动端调用```close()```发送FIN，进入LAST_ACK状态————**CLOSE_WAIT状态过多说明被动端忙于读写或阻塞，没有调用```close()```**
<br>
* 解决办法：
    * 1. 使用完socket调用close方法；
    * 2. socket读控制，当read返回0时（读到结尾），立即close；如果read返回-1，检查error返回码；如果不是```EAGAIN```，立即close；
    * 3. 数据库连接和访问等要**设置超时时间，避免阻塞；**
    * 4. 可以设置TCP的连接时长keep_alive_time

#### 3.更多异常情况
https://www.cnblogs.com/wanpengcoder/p/5356776.html

### 三、TCP的缺点？怎么优化？
---
## HTTP
### 一、简介
* 1. HTTP是TCP/IP中的一个应用层协议；用来协议数据交换过程和数据本身的格式。
* 2. HTTP服务器**不维护客户的状态信息**，即HTTP是一个无状态的协议(```stateless protocol```)。

### 二、HTTP/1.1特点
* 1. **默认持久连接**；在同一个tcp的连接中可以传送多个HTTP请求和响应；**一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接**

* 2. 多个请求和响应可以同时进行，但必须按照顺序.
* 3. 更加多的请求头和响应头(比如HTTP1.0没有的**Host的字段，用于访问多个虚拟站点中的一个**).

https://blog.csdn.net/u012813201/article/details/70211255

## IP
* 1. dotted decimal <---> hex number

---
# Linux 网络编程
## 常见Linux系统指令
netstat
top
ps 